/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

//#include <stdint.h>

//typedef volatile unsigned int long vuint32_t;
#include<platform_type.h>
#include <stdlib.h>
#define RCC_Base 0x40021000
#define GPIOPA_Base 0x40010800

#define RCC_APB2ENR *((volatile uint32_t*)(RCC_Base + 0X18))//ptr to volatile unsigned 32 bit integer that points to the mentioned adress
#define GPIO_CRH *((volatile uint32_t*)(GPIOPA_Base + 0x04))//ptr to volatile unsigned 32 bit integer that points to the mentioned adress
//#define GPIOPA_ODR *((volatile uint32_t*)(GPIOPA_Base + 0X0C))//ptr to volatile unsigned 32 bit integer that points to the mentioned adress

typedef union{
	vuint32_t all_bits;
	struct{
		vuint32_t reserved:13;
		vuint32_t pin13:1;
	}bits;
}ODRA_t;

volatile ODRA_t *ptr_PA =(volatile ODRA_t*)(GPIOPA_Base + 0X0C);
unsigned char g_variable[3] = {1,2,3};
unsigned char const c_variable[3] = {1,2,3};
unsigned char bss_var[2];


void *_sbrk (int incr){

	static unsigned char* heap_ptr = NULL ;
	unsigned char* prev_heap_ptr = NULL ;
	extern unsigned int _E_bss;
	extern unsigned int _heap_end;
	//check if the heap_ptr is used before
	if(heap_ptr == NULL)
		heap_ptr = (unsigned char*)&_E_bss;

	prev_heap_ptr = heap_ptr;
	 
	
	//protect stack
	if((heap_ptr+incr)>((unsigned char*)&_heap_end))
		return (void*) NULL;
	//reserve inc size
	heap_ptr += incr ;

	return (void*)prev_heap_ptr;

}

int main(void)
{
	int *ptr = (int*) malloc(4);
	RCC_APB2ENR |= 1<<2;//set bit 2
	GPIO_CRH &=0Xff0fffff;
	GPIO_CRH |=0X00200000;
 	volatile int i=0;
	while(1)
	{
		//GPIOPA_ODR |= 1<<13; //set bit 13
		ptr_PA->bits.pin13 = 1;
		for(i=0;i<60000;i++);
		//GPIOPA_ODR &= ~(1<<13);
		ptr_PA->bits.pin13 = 0;
		for(i=0;i<60000;i++);
	}



		free(ptr);
	return 0;
}
