/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "STM32F103x6.h"
#include "gpio_driver.h"
#include "lcd.h"
#include "keypad.h"
#include "exti_driver.h"


unsigned int TASK_A_FLAG, TASK_B_FLAG, SCHEDULE_FLAG = 0;

#define TaskA_Stack_Size 100 //bytes
#define TaskB_Stack_Size 100 //bytes

extern _estack;
//MAIN STACK
uint32_t _S_MSP = &_estack;
uint32_t _E_MSP;

//Process Stack TASK A
uint32_t _S_PSP_TA;
uint32_t _E_PSP_TA;

//Process Stack TASK B
uint32_t _S_PSP_TB;
uint32_t _E_PSP_TB;

//Loads a new stack pointer (PSP)
#define OS_SET_PSP(add)  		__asm volatile("mov r0,%0\n\t msr PSP,r0"::"r" (add))

//Set CONTROL[1] = 1 ,Switches stack pointer from MSP → PSP
#define OS_SWITCH_SP_TO_PSP		__asm volatile("mrs r0, CONTROL \n\t mov r1,#0x02 \n\t orr r0,r0,r1 \n\t msr CONTROL,r0")

//Set CONTROL[1] = 0 ,Switches stack pointer from PSP → MSP
#define OS_SWITCH_SP_TO_MSP		__asm volatile("mrs r0, CONTROL \n\t mov r1,#0x05 \n\t orr r0,r0,r1 \n\t msr CONTROL,r0")

// Uses an SVC (Supervisor Call) instruction to regain privileges
#define OS_Generate_Exception	__asm volatile("SVC #0x3")

//enum CPU_Access{
//	privileged,
//	unprivileged
//};


//void Switch_CPU_Access(enum CPU_Access level) {
//	switch(level) {
//	case privileged: // Clear bit 0 of CONTROL (privileged mode)
//		__asm("mrs r3, CONTROL \n\t"
//				"lsr r3, r3,#0x1 \n\t" // Shift right to clear bit 0
//				"lsl r3, r3,#0x1 \n\t" // Shift left to restore other bits
//				"msr CONTROL, r3");
//		break;
//	case unprivileged: // Set bit 0 of CONTROL (unprivileged mode)
//		__asm("mrs r3, CONTROL \n\t"
//				"orr r3, r3,#0x1 \n\t" // Set bit 0
//				"msr CONTROL, r3");
//		break;
//	}
//}

#define Switch_CPU_Access_to_Priviledge 			__asm("mrs r3, CONTROL \n\t lsr r3, r3,#0x1 \n\t lsl r3, r3,#0x1 \n\t msr CONTROL, r3")
#define Switch_CPU_Access_to_UnPriviledge 			__asm("mrs r3, CONTROL \n\t orr r3, r3,#0x1 \n\t msr CONTROL, r3")


void SVC_Handler(){
	Switch_CPU_Access_to_Priviledge;
}

int TASK_A(int a, int b, int c)
{
	return a+b+c;
}

int TASK_B(int a, int b, int c, int d)
{
	return a+b+c+d;
}

void EXTI9PB9_CALLBACK(){
	if(SCHEDULE_FLAG == 0)
	{
		TASK_A_FLAG =1;
		SCHEDULE_FLAG = 1;
	}else if(SCHEDULE_FLAG == 1)
	{
		TASK_B_FLAG = 1;
		SCHEDULE_FLAG = 0;
	}

}

void MainOS() {
	// MAIN STACK (MSP)
	_E_MSP = (_S_MSP - 512); // Reserve 512 bytes for OS

	// TASK A STACK (PSP_TA)
	_S_PSP_TA = (_E_MSP - 8); // 8-byte gap between OS and Task A
	_E_PSP_TA = (_S_PSP_TA - TaskA_Stack_Size); // 100 bytes for Task A

	// TASK B STACK (PSP_TB)
	_S_PSP_TB = (_S_PSP_TA - 8); // 8-byte gap between Task A and B
	_E_PSP_TB = (_S_PSP_TB - TaskB_Stack_Size); // 100 bytes for Task B
	while(1)
	{
		__asm("NOP");
		if(TASK_A_FLAG == 1)
		{
			//Set PSP Register = _S_PSP_TA
			OS_SET_PSP(_S_PSP_TA); // Set PSP to Task A's stack
			//SP -> PSP
			OS_SWITCH_SP_TO_PSP; // Switch to PSP
			//switch from privileged ->unprivileged
			Switch_CPU_Access_to_UnPriviledge;

			TASK_A_FLAG = TASK_A(1, 2, 3);

			//switch from unprivileged ->privileged
			OS_Generate_Exception;// Trigger SVC to regain privileges
			//SP -> MSP
			OS_SWITCH_SP_TO_MSP;

		}else if (TASK_B_FLAG == 1)
		{
			//Set PSP Register = _S_PSP_TB
			OS_SET_PSP(_S_PSP_TB);
			//SP -> PSP
			OS_SWITCH_SP_TO_PSP;

			//switch from privileged ->unprivileged
			Switch_CPU_Access_to_UnPriviledge;

			TASK_B_FLAG = TASK_B(1, 2, 3, 4);

			//switch from unprivileged ->privileged
			OS_Generate_Exception;
			//SP -> MSP
			OS_SWITCH_SP_TO_MSP;
		}
	}
}
int main(void)
{

	//Enable the clocks
	RCC_GPIOA_CLK_EN();
	RCC_GPIOB_CLK_EN();
	RCC_AFIO_CLK_EN();

	LCD_INIT();
	LCD_clear_screen();
	EXTI_PinCnfig_t EXTI_CFG ;
	EXTI_CFG.EXTI_PIN = EXTI9_PB9;
	EXTI_CFG.Trigger_Case = EXTI_Trigger_Rising;
	EXTI_CFG.Ptr_IRQ_CALLBACK = EXTI9PB9_CALLBACK ;
	EXTI_CFG.IRQ_EN = EXTI_IRQ_ENABLE;

	MCAL_EXTI_GPIO_INIT(&EXTI_CFG);

	MainOS();

	while(1)
	{
		if(SCHEDULE_FLAG)
		{
			SCHEDULE_FLAG = 0;
		}
	}

}

void BusFault_Handler(){

}
void HardFault_Handler(){

}

