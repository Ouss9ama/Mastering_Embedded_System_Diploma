/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

 #if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include <stdint.h>

//RCC
#define RCC_base 0x40021000
#define RCC_APB2ENR  *((volatile uint32_t*)(RCC_base + 0x18))

// GPIO A
#define GPIOPA_Base 0x40010800
#define GPIOA_CRH   *((volatile uint32_t*)(GPIOPA_Base + 0x04))//ptr to volatile unsigned 32 bit integer that points to the mentioned adress
#define GPIOA_CRL   *((volatile uint32_t*)(GPIOPA_Base + 0x00))
#define GPIOPA_ODR  *((volatile uint32_t*)(GPIOPA_Base + 0x0C))//ptr to volatile unsigned 32 bit integer that points to the mentioned adress
#define GPIOPA_IDR  *((volatile uint32_t*)(GPIOPA_Base + 0x08))

//GPIO B
#define GPIOPB_Base 0x40010C00
#define GPIOB_CRH   *((volatile uint32_t*)(GPIOPB_Base + 0x04))//ptr to volatile unsigned 32 bit integer that points to the mentioned adress
#define GPIOB_CRL   *((volatile uint32_t*)(GPIOPB_Base + 0x00))
#define GPIOPB_ODR  *((volatile uint32_t*)(GPIOPB_Base + 0x0C))
#define GPIOPB_IDR  *((volatile uint32_t*)(GPIOPB_Base + 0x08))

void clock_init(){
	//Enable clock for GPIOA
	RCC_APB2ENR |= (1<<2);

	////Enable clock for GPIOB
	RCC_APB2ENR |= (1<<3);



}

void GPIO_inti(){
	//PORT A pin 1: input float
	GPIOA_CRL = 0x0; //clearing the register
	GPIOA_CRL &= ~(0b11<<4);//MODE (00: Input mode)
	GPIOA_CRL |= (0b01<<6);//CNF (01: Floating input).

	//PORT B pin 1: output pushpull mode
	GPIOB_CRL = 0x0;
	GPIOB_CRL |= (0b01<<4);//MODE (01: Output mode, max speed 10 MHz).
	GPIOB_CRL &= ~(0b11<<6);//CNF (00: General purpose output push-pull).


	//PORT A pin 13: input float
	GPIOA_CRH &= ~(0b11<<20);//MODE (00: Input mode).
	GPIOA_CRH |= (0b01<<22);//CNF (01: Floating input).


	//PORT B pin 13: output pushpull mode
	GPIOB_CRH |= (0b01<<20);//MODE (01: Output mode, max speed 10 MHz).
	GPIOB_CRH &= ~(0b11<<22);//CNF (00: General purpose output push-pull).

}

void my_wait(int x){
	unsigned int i,j;
	for(i=0; i<x ; i++)
	{
		for(j=0; j<255; j++);
	}
}
int main(void)
{

	clock_init();
	GPIO_inti();


	while(1){

		//PA1 connected to external pull-up resistor
		if(((GPIOPA_IDR & (1<<1))>>1) == 0)//Check if Pin 1 is low (button pressed)
		{
			GPIOPB_ODR ^= (1<<1);//// Toggle Pin 1 on Port B
			while(((GPIOPA_IDR & (1<<1))>>1) == 0);//Wait for button release (single press)
		}

		//PA13 connected to external pull-up resistor
		if(((GPIOPA_IDR & (1<<13))>>13) == 1)//Check if Pin 1 is low (button pressed)
		{
			GPIOPB_ODR ^= (1<<13);//// Toggle Pin 1 on Port B
		}
		my_wait(1);
	}

}

